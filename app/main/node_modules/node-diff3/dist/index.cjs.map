{
  "version": 3,
  "sources": ["../index.mjs"],
  "sourcesContent": ["export {\n  LCS,\n  diffComm,\n  diffIndices,\n  diffPatch,\n  diff3MergeRegions,\n  diff3Merge,\n  mergeDiff3,\n  merge,\n  mergeDigIn,\n  patch,\n  stripPatch,\n  invertPatch\n};\n\n\n// Text diff algorithm following Hunt and McIlroy 1976.\n// J. W. Hunt and M. D. McIlroy, An algorithm for differential buffer\n// comparison, Bell Telephone Laboratories CSTR #41 (1976)\n// http://www.cs.dartmouth.edu/~doug/\n// https://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n//\n// Expects two arrays, finds longest common sequence\nfunction LCS(buffer1, buffer2) {\n\n  let equivalenceClasses = {};\n  for (let j = 0; j < buffer2.length; j++) {\n    const item = buffer2[j];\n    if (equivalenceClasses[item]) {\n      equivalenceClasses[item].push(j);\n    } else {\n      equivalenceClasses[item] = [j];\n    }\n  }\n\n  const NULLRESULT = { buffer1index: -1, buffer2index: -1, chain: null };\n  let candidates = [NULLRESULT];\n\n  for (let i = 0; i < buffer1.length; i++) {\n    const item = buffer1[i];\n    const buffer2indices = equivalenceClasses[item] || [];\n    let r = 0;\n    let c = candidates[0];\n\n    for (let jx = 0; jx < buffer2indices.length; jx++) {\n      const j = buffer2indices[jx];\n\n      let s;\n      for (s = r; s < candidates.length; s++) {\n        if ((candidates[s].buffer2index < j) && ((s === candidates.length - 1) || (candidates[s + 1].buffer2index > j))) {\n          break;\n        }\n      }\n\n      if (s < candidates.length) {\n        const newCandidate = { buffer1index: i, buffer2index: j, chain: candidates[s] };\n        if (r === candidates.length) {\n          candidates.push(c);\n        } else {\n          candidates[r] = c;\n        }\n        r = s + 1;\n        c = newCandidate;\n        if (r === candidates.length) {\n          break; // no point in examining further (j)s\n        }\n      }\n    }\n\n    candidates[r] = c;\n  }\n\n  // At this point, we know the LCS: it's in the reverse of the\n  // linked-list through .chain of candidates[candidates.length - 1].\n\n  return candidates[candidates.length - 1];\n}\n\n\n// We apply the LCS to build a 'comm'-style picture of the\n// differences between buffer1 and buffer2.\nfunction diffComm(buffer1, buffer2) {\n  const lcs = LCS(buffer1, buffer2);\n  let result = [];\n  let tail1 = buffer1.length;\n  let tail2 = buffer2.length;\n  let common = {common: []};\n\n  function processCommon() {\n    if (common.common.length) {\n      common.common.reverse();\n      result.push(common);\n      common = {common: []};\n    }\n  }\n\n  for (let candidate = lcs; candidate !== null; candidate = candidate.chain) {\n    let different = {buffer1: [], buffer2: []};\n\n    while (--tail1 > candidate.buffer1index) {\n      different.buffer1.push(buffer1[tail1]);\n    }\n\n    while (--tail2 > candidate.buffer2index) {\n      different.buffer2.push(buffer2[tail2]);\n    }\n\n    if (different.buffer1.length || different.buffer2.length) {\n      processCommon();\n      different.buffer1.reverse();\n      different.buffer2.reverse();\n      result.push(different);\n    }\n\n    if (tail1 >= 0) {\n      common.common.push(buffer1[tail1]);\n    }\n  }\n\n  processCommon();\n\n  result.reverse();\n  return result;\n}\n\n\n// We apply the LCS to give a simple representation of the\n// offsets and lengths of mismatched chunks in the input\n// buffers. This is used by diff3MergeRegions.\nfunction diffIndices(buffer1, buffer2) {\n  const lcs = LCS(buffer1, buffer2);\n  let result = [];\n  let tail1 = buffer1.length;\n  let tail2 = buffer2.length;\n\n  for (let candidate = lcs; candidate !== null; candidate = candidate.chain) {\n    const mismatchLength1 = tail1 - candidate.buffer1index - 1;\n    const mismatchLength2 = tail2 - candidate.buffer2index - 1;\n    tail1 = candidate.buffer1index;\n    tail2 = candidate.buffer2index;\n\n    if (mismatchLength1 || mismatchLength2) {\n      result.push({\n        buffer1: [tail1 + 1, mismatchLength1],\n        buffer1Content: buffer1.slice(tail1 + 1, tail1 + 1 + mismatchLength1),\n        buffer2: [tail2 + 1, mismatchLength2],\n        buffer2Content: buffer2.slice(tail2 + 1, tail2 + 1 + mismatchLength2)\n      });\n    }\n  }\n\n  result.reverse();\n  return result;\n}\n\n\n// We apply the LCS to build a JSON representation of a\n// diff(1)-style patch.\nfunction diffPatch(buffer1, buffer2) {\n  const lcs = LCS(buffer1, buffer2);\n  let result = [];\n  let tail1 = buffer1.length;\n  let tail2 = buffer2.length;\n\n  function chunkDescription(buffer, offset, length) {\n    let chunk = [];\n    for (let i = 0; i < length; i++) {\n      chunk.push(buffer[offset + i]);\n    }\n    return {\n      offset: offset,\n      length: length,\n      chunk: chunk\n    };\n  }\n\n  for (let candidate = lcs; candidate !== null; candidate = candidate.chain) {\n    const mismatchLength1 = tail1 - candidate.buffer1index - 1;\n    const mismatchLength2 = tail2 - candidate.buffer2index - 1;\n    tail1 = candidate.buffer1index;\n    tail2 = candidate.buffer2index;\n\n    if (mismatchLength1 || mismatchLength2) {\n      result.push({\n        buffer1: chunkDescription(buffer1, candidate.buffer1index + 1, mismatchLength1),\n        buffer2: chunkDescription(buffer2, candidate.buffer2index + 1, mismatchLength2)\n      });\n    }\n  }\n\n  result.reverse();\n  return result;\n}\n\n\n// Given three buffers, A, O, and B, where both A and B are\n// independently derived from O, returns a fairly complicated\n// internal representation of merge decisions it's taken. The\n// interested reader may wish to consult\n//\n// Sanjeev Khanna, Keshav Kunal, and Benjamin C. Pierce.\n// 'A Formal Investigation of ' In Arvind and Prasad,\n// editors, Foundations of Software Technology and Theoretical\n// Computer Science (FSTTCS), December 2007.\n//\n// (http://www.cis.upenn.edu/~bcpierce/papers/diff3-short.pdf)\n//\nfunction diff3MergeRegions(a, o, b) {\n\n  // \"hunks\" are array subsets where `a` or `b` are different from `o`\n  // https://www.gnu.org/software/diffutils/manual/html_node/diff3-Hunks.html\n  let hunks = [];\n  function addHunk(h, ab) {\n    hunks.push({\n      ab: ab,\n      oStart: h.buffer1[0],\n      oLength: h.buffer1[1],   // length of o to remove\n      abStart: h.buffer2[0],\n      abLength: h.buffer2[1]   // length of a/b to insert\n      // abContent: (ab === 'a' ? a : b).slice(h.buffer2[0], h.buffer2[0] + h.buffer2[1])\n    });\n  }\n\n  diffIndices(o, a).forEach(item => addHunk(item, 'a'));\n  diffIndices(o, b).forEach(item => addHunk(item, 'b'));\n  hunks.sort((x,y) => x.oStart - y.oStart);\n\n  let results = [];\n  let currOffset = 0;\n\n  function advanceTo(endOffset) {\n    if (endOffset > currOffset) {\n      results.push({\n        stable: true,\n        buffer: 'o',\n        bufferStart: currOffset,\n        bufferLength: endOffset - currOffset,\n        bufferContent: o.slice(currOffset, endOffset)\n      });\n      currOffset = endOffset;\n    }\n  }\n\n  while (hunks.length) {\n    let hunk = hunks.shift();\n    let regionStart = hunk.oStart;\n    let regionEnd = hunk.oStart + hunk.oLength;\n    let regionHunks = [hunk];\n    advanceTo(regionStart);\n\n    // Try to pull next overlapping hunk into this region\n    while (hunks.length) {\n      const nextHunk = hunks[0];\n      const nextHunkStart = nextHunk.oStart;\n      if (nextHunkStart > regionEnd) break;   // no overlap\n\n      regionEnd = Math.max(regionEnd, nextHunkStart + nextHunk.oLength);\n      regionHunks.push(hunks.shift());\n    }\n\n    if (regionHunks.length === 1) {\n      // Only one hunk touches this region, meaning that there is no conflict here.\n      // Either `a` or `b` is inserting into a region of `o` unchanged by the other.\n      if (hunk.abLength > 0) {\n        const buffer = (hunk.ab === 'a' ? a : b);\n        results.push({\n          stable: true,\n          buffer: hunk.ab,\n          bufferStart: hunk.abStart,\n          bufferLength: hunk.abLength,\n          bufferContent: buffer.slice(hunk.abStart, hunk.abStart + hunk.abLength)\n        });\n      }\n    } else {\n      // A true a/b conflict. Determine the bounds involved from `a`, `o`, and `b`.\n      // Effectively merge all the `a` hunks into one giant hunk, then do the\n      // same for the `b` hunks; then, correct for skew in the regions of `o`\n      // that each side changed, and report appropriate spans for the three sides.\n      let bounds = {\n        a: [a.length, -1, o.length, -1],\n        b: [b.length, -1, o.length, -1]\n      };\n      while (regionHunks.length) {\n        hunk = regionHunks.shift();\n        const oStart = hunk.oStart;\n        const oEnd = oStart + hunk.oLength;\n        const abStart = hunk.abStart;\n        const abEnd = abStart + hunk.abLength;\n        let b = bounds[hunk.ab];\n        b[0] = Math.min(abStart, b[0]);\n        b[1] = Math.max(abEnd, b[1]);\n        b[2] = Math.min(oStart, b[2]);\n        b[3] = Math.max(oEnd, b[3]);\n      }\n\n      const aStart = bounds.a[0] + (regionStart - bounds.a[2]);\n      const aEnd = bounds.a[1] + (regionEnd - bounds.a[3]);\n      const bStart = bounds.b[0] + (regionStart - bounds.b[2]);\n      const bEnd = bounds.b[1] + (regionEnd - bounds.b[3]);\n\n      let result = {\n        stable: false,\n        aStart: aStart,\n        aLength: aEnd - aStart,\n        aContent: a.slice(aStart, aEnd),\n        oStart: regionStart,\n        oLength: regionEnd - regionStart,\n        oContent: o.slice(regionStart, regionEnd),\n        bStart: bStart,\n        bLength: bEnd - bStart,\n        bContent: b.slice(bStart, bEnd)\n      };\n      results.push(result);\n    }\n    currOffset = regionEnd;\n  }\n\n  advanceTo(o.length);\n\n  return results;\n}\n\n\n// Applies the output of diff3MergeRegions to actually\n// construct the merged buffer; the returned result alternates\n// between 'ok' and 'conflict' blocks.\n// A \"false conflict\" is where `a` and `b` both change the same from `o`\nfunction diff3Merge(a, o, b, options) {\n  let defaults = {\n    excludeFalseConflicts: true,\n    stringSeparator: /\\s+/\n  };\n  options = Object.assign(defaults, options);\n\n  if (typeof a === 'string') a = a.split(options.stringSeparator);\n  if (typeof o === 'string') o = o.split(options.stringSeparator);\n  if (typeof b === 'string') b = b.split(options.stringSeparator);\n\n  let results = [];\n  const regions = diff3MergeRegions(a, o, b);\n\n  let okBuffer = [];\n  function flushOk() {\n    if (okBuffer.length) {\n      results.push({ ok: okBuffer });\n    }\n    okBuffer = [];\n  }\n\n  function isFalseConflict(a, b) {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n\n  regions.forEach(region =>  {\n    if (region.stable) {\n      okBuffer.push(...region.bufferContent);\n    } else {\n      if (options.excludeFalseConflicts && isFalseConflict(region.aContent, region.bContent)) {\n        okBuffer.push(...region.aContent);\n      } else {\n        flushOk();\n        results.push({\n          conflict: {\n            a: region.aContent,\n            aIndex: region.aStart,\n            o: region.oContent,\n            oIndex: region.oStart,\n            b: region.bContent,\n            bIndex: region.bStart\n          }\n        });\n      }\n    }\n  });\n\n  flushOk();\n  return results;\n}\n\n\nfunction mergeDiff3(a, o, b, options) {\n  const defaults = {\n    excludeFalseConflicts: true,\n    stringSeparator: /\\s+/,\n    label: {}\n  };\n  options = Object.assign(defaults, options);\n\n  const aSection = '<<<<<<<' + (options.label.a ? ` ${options.label.a}` : '');\n  const oSection = '|||||||' + (options.label.o ? ` ${options.label.o}` : '');\n  const xSection = '=======';\n  const bSection = '>>>>>>>' + (options.label.b ? ` ${options.label.b}` : '');\n\n  const regions = diff3Merge(a, o, b, options);\n  let conflict = false;\n  let result = [];\n\n  regions.forEach(region => {\n    if (region.ok) {\n      result = result.concat(region.ok);\n    } else if (region.conflict) {\n      conflict = true;\n      result = result.concat(\n        [aSection],\n        region.conflict.a,\n        [oSection],\n        region.conflict.o,\n        [xSection],\n        region.conflict.b,\n        [bSection]\n      );\n    }\n  });\n\n  return {\n    conflict: conflict,\n    result: result\n  };\n}\n\n\nfunction merge(a, o, b, options) {\n  const defaults = {\n    excludeFalseConflicts: true,\n    stringSeparator: /\\s+/,\n    label: {}\n  };\n  options = Object.assign(defaults, options);\n\n  const aSection = '<<<<<<<' + (options.label.a ? ` ${options.label.a}` : '');\n  const xSection = '=======';\n  const bSection = '>>>>>>>' + (options.label.b ? ` ${options.label.b}` : '');\n\n  const regions = diff3Merge(a, o, b, options);\n  let conflict = false;\n  let result = [];\n\n  regions.forEach(region => {\n    if (region.ok) {\n      result = result.concat(region.ok);\n    } else if (region.conflict) {\n      conflict = true;\n      result = result.concat(\n        [aSection],\n        region.conflict.a,\n        [xSection],\n        region.conflict.b,\n        [bSection]\n      );\n    }\n  });\n\n  return {\n    conflict: conflict,\n    result: result\n  };\n}\n\n\nfunction mergeDigIn(a, o, b, options) {\n  const defaults = {\n    excludeFalseConflicts: true,\n    stringSeparator: /\\s+/,\n    label: {}\n  };\n  options = Object.assign(defaults, options);\n\n  const aSection = '<<<<<<<' + (options.label.a ? ` ${options.label.a}` : '');\n  const xSection = '=======';\n  const bSection = '>>>>>>>' + (options.label.b ? ` ${options.label.b}` : '');\n\n  const regions = diff3Merge(a, o, b, options);\n  let conflict = false;\n  let result = [];\n\n  regions.forEach(region => {\n    if (region.ok) {\n      result = result.concat(region.ok);\n    } else {\n      const c = diffComm(region.conflict.a, region.conflict.b);\n      for (let j = 0; j < c.length; j++) {\n        let inner = c[j];\n        if (inner.common) {\n          result = result.concat(inner.common);\n        } else {\n          conflict = true;\n          result = result.concat(\n            [aSection],\n            inner.buffer1,\n            [xSection],\n            inner.buffer2,\n            [bSection]\n          );\n        }\n      }\n    }\n  });\n\n  return {\n    conflict: conflict,\n    result: result\n  };\n}\n\n\n// Applies a patch to a buffer.\n// Given buffer1 and buffer2, `patch(buffer1, diffPatch(buffer1, buffer2))` should give buffer2.\nfunction patch(buffer, patch) {\n  let result = [];\n  let currOffset = 0;\n\n  function advanceTo(targetOffset) {\n    while (currOffset < targetOffset) {\n      result.push(buffer[currOffset]);\n      currOffset++;\n    }\n  }\n\n  for (let chunkIndex = 0; chunkIndex < patch.length; chunkIndex++) {\n    let chunk = patch[chunkIndex];\n    advanceTo(chunk.buffer1.offset);\n    for (let itemIndex = 0; itemIndex < chunk.buffer2.chunk.length; itemIndex++) {\n      result.push(chunk.buffer2.chunk[itemIndex]);\n    }\n    currOffset += chunk.buffer1.length;\n  }\n\n  advanceTo(buffer.length);\n  return result;\n}\n\n\n// Takes the output of diffPatch(), and removes extra information from it.\n// It can still be used by patch(), below, but can no longer be inverted.\nfunction stripPatch(patch) {\n  return patch.map(chunk => ({\n    buffer1: { offset: chunk.buffer1.offset, length: chunk.buffer1.length },\n    buffer2: { chunk: chunk.buffer2.chunk }\n  }));\n}\n\n\n// Takes the output of diffPatch(), and inverts the sense of it, so that it\n// can be applied to buffer2 to give buffer1 rather than the other way around.\nfunction invertPatch(patch) {\n  return patch.map(chunk => ({\n    buffer1: chunk.buffer2,\n    buffer2: chunk.buffer1\n  }));\n}\n"],
  "mappings": "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",
  "names": []
}
